"""Integration tests for the complete WebAuthn authentication flow."""
import base64
import json
from datetime import datetime
from uuid import uuid4

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from src.infrastructure.auth.challenge_store import ChallengeStore
from src.infrastructure.auth.credential_validator import CredentialValidator
from src.infrastructure.auth.webauthn_manager import WebAuthnManager
from src.infrastructure.database.models.auth import User, UserDevice
from src.infrastructure.database.repositories.device import DeviceRepository
from src.infrastructure.database.unit_of_work import UnitOfWork


@pytest.fixture
async def test_user(async_session: AsyncSession):
    """Create a test user."""
    user = User(
        id=uuid4(),
        external_id=f"test-{uuid4()}",
        email="test@example.com",
        username="testuser",
        full_name="Test User",
        is_active=True,
        is_verified=True
    )
    
    async_session.add(user)
    await async_session.commit()
    await async_session.refresh(user)
    
    yield user
    
    # Cleanup
    await async_session.delete(user)
    await async_session.commit()


@pytest.fixture
async def webauthn_manager():
    """Create WebAuthn manager instance."""
    return WebAuthnManager()


@pytest.fixture
async def challenge_store(redis_client):
    """Create challenge store with Redis client."""
    return ChallengeStore(redis_client)


class TestWebAuthnRegistrationFlow:
    """Test the complete WebAuthn registration flow."""
    
    @pytest.mark.asyncio
    async def test_full_registration_flow(
        self,
        async_session: AsyncSession,
        test_user: User,
        webauthn_manager: WebAuthnManager,
        challenge_store: ChallengeStore
    ):
        """Test complete device registration flow."""
        # Step 1: Generate registration options
        options = await webauthn_manager.generate_registration_options(
            user_id=str(test_user.id),
            user_name=test_user.email,
            user_display_name=test_user.full_name or test_user.email,
            exclude_credentials=[]
        )
        
        assert options.challenge
        assert options.rp_id
        assert options.user_id
        
        # Step 2: Store challenge
        stored = await challenge_store.store_challenge(
            user_id=str(test_user.id),
            challenge=options.challenge,
            challenge_type="registration"
        )
        assert stored is True
        
        # Step 3: Simulate client response (simplified for testing)
        # In real scenario, this would come from the browser's WebAuthn API
        client_data = {
            "type": "webauthn.create",
            "challenge": options.challenge,
            "origin": f"https://{options.rp_id}",
            "crossOrigin": False
        }
        client_data_json = base64.urlsafe_b64encode(
            json.dumps(client_data).encode()
        ).decode().rstrip('=')
        
        # Create a mock attestation object (simplified)
        # In production, this would be generated by the authenticator
        mock_credential_id = base64.urlsafe_b64encode(b"test-credential-id").decode().rstrip('=')
        mock_public_key = {
            1: 2,  # kty: EC
            3: -7, # alg: ES256
            -1: 1, # crv: P-256
            -2: b"x" * 32,  # x coordinate
            -3: b"y" * 32   # y coordinate
        }
        
        # Step 4: Verify registration (with mock data)
        # Note: This is simplified - real verification would validate signatures
        retrieved_challenge = await challenge_store.retrieve_challenge(
            user_id=str(test_user.id),
            challenge_type="registration"
        )
        assert retrieved_challenge == options.challenge
        
        # Step 5: Store device in database
        async with UnitOfWork(async_session) as uow:
            device_repo = DeviceRepository(UserDevice, async_session, test_user.tenant_id)
            
            device = await device_repo.create({
                "id": uuid4(),
                "user_id": test_user.id,
                "device_name": "Test Device",
                "device_type": "webauthn",
                "device_id": mock_credential_id,
                "credential_id": mock_credential_id,
                "public_key": base64.urlsafe_b64encode(
                    CredentialValidator.extract_public_key_from_cose(mock_public_key).encode()
                ).decode().rstrip('='),
                "sign_count": 0,
                "trust_score": 50.0,
                "is_trusted": False,
                "user_agent": "Test User Agent"
            })
            
            await uow.commit()
        
        assert device.id
        assert device.credential_id == mock_credential_id
        assert device.sign_count == 0
    
    @pytest.mark.asyncio
    async def test_registration_with_existing_device(
        self,
        async_session: AsyncSession,
        test_user: User,
        webauthn_manager: WebAuthnManager
    ):
        """Test registration when user already has devices."""
        # Create existing device
        existing_device = UserDevice(
            id=uuid4(),
            user_id=test_user.id,
            device_name="Existing Device",
            device_type="webauthn",
            device_id="existing-device-id",
            credential_id="existing-credential-id",
            public_key="existing-public-key",
            sign_count=5,
            trust_score=80.0,
            is_trusted=True
        )
        
        async_session.add(existing_device)
        await async_session.commit()
        
        # Generate options with exclusion
        options = await webauthn_manager.generate_registration_options(
            user_id=str(test_user.id),
            user_name=test_user.email,
            user_display_name=test_user.full_name or test_user.email,
            exclude_credentials=[{
                "type": "public-key",
                "id": existing_device.credential_id
            }]
        )
        
        # Verify existing credential is excluded
        assert len(options.exclude_credentials) == 1
        assert options.exclude_credentials[0]["id"] == existing_device.credential_id


class TestWebAuthnAuthenticationFlow:
    """Test the complete WebAuthn authentication flow."""
    
    @pytest.mark.asyncio
    async def test_full_authentication_flow(
        self,
        async_session: AsyncSession,
        test_user: User,
        webauthn_manager: WebAuthnManager,
        challenge_store: ChallengeStore
    ):
        """Test complete device authentication flow."""
        # Setup: Create a registered device
        device = UserDevice(
            id=uuid4(),
            user_id=test_user.id,
            device_name="Test Device",
            device_type="webauthn",
            device_id="test-device-id",
            credential_id="test-credential-id",
            public_key=base64.urlsafe_b64encode(json.dumps({
                1: 2,  # kty: EC
                3: -7, # alg: ES256
                -1: 1, # crv: P-256
                -2: base64.b64encode(b"x" * 32).decode(),
                -3: base64.b64encode(b"y" * 32).decode()
            }).encode()).decode().rstrip('='),
            sign_count=10,
            trust_score=75.0,
            is_trusted=False
        )
        
        async_session.add(device)
        await async_session.commit()
        
        # Step 1: Generate authentication options
        options = await webauthn_manager.generate_authentication_options(
            allow_credentials=[{
                "type": "public-key",
                "id": device.credential_id
            }]
        )
        
        assert options.challenge
        assert len(options.allow_credentials) == 1
        assert options.allow_credentials[0]["id"] == device.credential_id
        
        # Step 2: Store challenge
        stored = await challenge_store.store_challenge(
            user_id=str(test_user.id),
            challenge=options.challenge,
            challenge_type="authentication"
        )
        assert stored is True
        
        # Step 3: Simulate client response
        client_data = {
            "type": "webauthn.get",
            "challenge": options.challenge,
            "origin": f"https://{options.rp_id}",
            "crossOrigin": False
        }
        client_data_json = base64.urlsafe_b64encode(
            json.dumps(client_data).encode()
        ).decode().rstrip('=')
        
        # Step 4: Verify challenge was consumed
        retrieved_challenge = await challenge_store.retrieve_challenge(
            user_id=str(test_user.id),
            challenge_type="authentication"
        )
        assert retrieved_challenge == options.challenge
        
        # Verify challenge is consumed after retrieval
        second_retrieval = await challenge_store.retrieve_challenge(
            user_id=str(test_user.id),
            challenge_type="authentication"
        )
        assert second_retrieval is None
        
        # Step 5: Update device sign count
        async with UnitOfWork(async_session) as uow:
            device_repo = DeviceRepository(UserDevice, async_session, test_user.tenant_id)
            
            updated_device = await device_repo.update_last_used(
                device.id,
                new_sign_count=11  # Increment from 10 to 11
            )
            
            await uow.commit()
        
        assert updated_device.sign_count == 11
        assert updated_device.last_used_at is not None
        assert updated_device.use_count == 1


class TestWebAuthnSecurity:
    """Test WebAuthn security features."""
    
    @pytest.mark.asyncio
    async def test_challenge_expiry(
        self,
        test_user: User,
        challenge_store: ChallengeStore
    ):
        """Test that challenges expire properly."""
        # Store challenge
        challenge = "test-challenge-expiry"
        await challenge_store.store_challenge(
            user_id=str(test_user.id),
            challenge=challenge,
            challenge_type="registration"
        )
        
        # Retrieve immediately - should work
        retrieved = await challenge_store.retrieve_challenge(
            user_id=str(test_user.id),
            challenge_type="registration"
        )
        assert retrieved == challenge
        
        # Try to retrieve again - should be None (consumed)
        retrieved_again = await challenge_store.retrieve_challenge(
            user_id=str(test_user.id),
            challenge_type="registration"
        )
        assert retrieved_again is None
    
    @pytest.mark.asyncio
    async def test_counter_validation_prevents_replay(
        self,
        async_session: AsyncSession,
        test_user: User
    ):
        """Test that sign counter prevents replay attacks."""
        # Create device with sign count
        device = UserDevice(
            id=uuid4(),
            user_id=test_user.id,
            device_name="Counter Test Device",
            device_type="webauthn",
            device_id="counter-test-id",
            credential_id="counter-test-credential",
            public_key="test-public-key",
            sign_count=100,
            trust_score=50.0,
            is_trusted=False
        )
        
        async_session.add(device)
        await async_session.commit()
        
        # Test counter validation
        # Valid: new counter > stored counter
        assert CredentialValidator.validate_counter(101, 100) is True
        
        # Invalid: new counter = stored counter (replay)
        assert CredentialValidator.validate_counter(100, 100) is False
        
        # Invalid: new counter < stored counter (replay)
        assert CredentialValidator.validate_counter(99, 100) is False
        
        # Special case: both zero (some authenticators don't implement counters)
        assert CredentialValidator.validate_counter(0, 0, allow_zero=True) is True
    
    @pytest.mark.asyncio
    async def test_origin_validation(self):
        """Test origin validation for preventing cross-origin attacks."""
        valid_origins = ["https://example.com", "https://app.example.com"]
        
        # Valid origins
        assert WebAuthnValidator.validate_origin("https://example.com", valid_origins) is True
        assert WebAuthnValidator.validate_origin("https://app.example.com", valid_origins) is True
        
        # Invalid origins
        assert WebAuthnValidator.validate_origin("https://evil.com", valid_origins) is False
        assert WebAuthnValidator.validate_origin("http://example.com", valid_origins) is False  # Wrong protocol
    
    @pytest.mark.asyncio
    async def test_user_verification_required(self):
        """Test that user verification is enforced."""
        # Create authenticator data with flags
        # Flags byte at position 32:
        # bit 0 (0x01): User Present (UP)
        # bit 2 (0x04): User Verified (UV)
        
        auth_data_verified = bytearray(37)
        auth_data_verified[32] = 0x05  # UP=1, UV=1
        
        auth_data_not_verified = bytearray(37)
        auth_data_not_verified[32] = 0x01  # UP=1, UV=0
        
        # When user verification is required
        assert WebAuthnValidator.validate_user_verification(
            bytes(auth_data_verified), "required"
        ) is True
        
        assert WebAuthnValidator.validate_user_verification(
            bytes(auth_data_not_verified), "required"
        ) is False
        
        # When user verification is preferred (accepts both)
        assert WebAuthnValidator.validate_user_verification(
            bytes(auth_data_verified), "preferred"
        ) is True
        
        assert WebAuthnValidator.validate_user_verification(
            bytes(auth_data_not_verified), "preferred"
        ) is True